---
title: Gitea Actions + Nginx + Docker = CI/CD
description: 사내 환경(Gitea Actions, Nginx) + Docker로 CICD 환경 구축하기
thumbnail: /thumbnails/together.png
date: "Sep 18, 2025"
---

## Gitea Actions 기반 CI/CD: Nginx와 Docker를 활용한 웹 배포 자동화

CICD란 무엇인가 구글링을 해보면 '지속적 통합(Continuous Integration)'과 '지속적 배포(Continuous Delivery/Deployment)'를 의미한다고 나온다. 쉽게 풀어보자면 정기적으로 업데이트 되는 코드를 자동으로 통합해주고 배포해준다는 뜻이다.

<br />
회사에서 관리하는 웹이 많아질수록 배포 자동화의 필요성을 느꼈다. 올해 늦봄 즈음에
CICD를 작업해보고 싶다고 팀에 말했는데, 반응이 "ㅇㅋ 다만 일 없을 때 시도해보자."
였다. 그런데 도저히 시간이 나지 않는 거다... 회사에는 언제나 일이 존재하고 퇴근하면
사이드 프로젝트 하느라 바쁘고...

시도도 못하다가 이번에 새로운 프론트엔드 팀장님을 모시게 되면서 드디어 CICD 작업을 하게 되었다.

<div className="bar" />

- 기존 방식❓

기존 방식은 로컬에서 작업하고 실장님이 확인한 뒤 빌드하여 정적 파일을 서버에 직접 넣는 방식으로 진행했다. 이 방식을 무척이나 바꾸고 싶었지만 서버를 건드려야 한단 생각에 차일피일 미룬 것도 사실이다. 우선 차선으로 서버에 git을 연결하여 서버 내에서 빌드하는 방식으로 변경했다.

서버에 git을 연결한 며칠 뒤, 팀장님이 배포 환경을 만들었다며 현재 내가 관리하고 있는 사이트에 CICD를 연동하자고 하셨다.

<div className="bar" />

- 새로운 배포 방식❓

<ol>
  <li>1. Gitea</li>
  <li>2. Docker</li>
  <li>3. Nginx</li>
</ol>
<br />
회사 내 git 플랫폼으로 gitea를 사용한다. Gitea에도 CICD를 돕는 Gitea Actions
라는 기능이 있어 이걸 이용하기로 했다. Gitea에서 빌드한 페이지가 어느 환경에서나
동일하게 실행될 수 있도록 Docker를 사용하기로 했다. 이 도커 컨테이너는 회사 내
웹 서버인 Nginx와 연결되어 외부 사용자가 접근할 수 있게 된다.

<div className="bar" />

## Gitea Actions의 역할 파악

먼저 Gitea Actions의 역할이 무엇인지 살펴 보자.

<MDXImage
  src="/posts/cicd/chart.png"
  alt="what gitea actions do"
  style={{ width: "50%" }}
/>
(다이어그램은 mermaid live editor를 이용해 작성했다.)

Gitea actions는 [docker 설치 > npm package 설치 > 새로운 docker compose 빌드 > 서버에 배포] 단계를 이룬다. 이 과정이 곧 CICD의 전체적인 흐름이기에 미리 파악해두면 코드 짤 때 길 잃을 일이 적다. 난 처음에 무턱대고 했다가 삽질을 많이 했다. ㅎㅎ

<br />

## 로컬로 도커 띄우기

게다가 뭐가 그리 급한지 로컬로 시도도 안 해보고 바로 gitea에 도커 파일을 올려가며 일을 진행했다. nginx 파일을 빨리 바꿔보고 싶었기 때문에...ㅋㅋㅋㅋ 이러면 당연히 헤맬 수밖에 없다. 보다 못한 팀장님이 먼저 로컬로 해보고 성공하면 올려 보라고 조언을 주셔서 로컬 먼저 진행했다. 차분하게 하자. 차분하게!

<br />
<br />
a. 도커 관련 파일을 생성한다.

<CodeBlock>
```

// Dockerfile.dev

// 개발용 Dockerfile - npm 개발 서버
FROM node:18-alpine

// 작업 디렉토리 설정
WORKDIR /app

// package.json과 package-lock.json 복사
COPY package\*.json ./

// 의존성 설치 (React 버전 충돌 해결)
RUN npm ci --legacy-peer-deps

// 소스 코드 복사
COPY . .

// 개발 서버 포트 노출 (Next.js 기본 포트)
EXPOSE 3000

// 개발 서버 실행
CMD ["npm", "run", "dev"]

```
</CodeBlock>

<CodeBlock>
```

// docker-compose.local.yml

services:
'myprojectname'-local:
build:
context: .
dockerfile: Dockerfile.dev
container_name: 'myprojectname'-local
ports: - "3002:3001"
environment: - NODE_ENV=development
restart: unless-stopped
networks: - 'myprojectname'-dev-network # 볼륨 마운트로 소스 코드 변경사항 실시간 반영
volumes: - .:/app - /app/node_modules
extra_hosts: - "host.docker.internal:host-gateway"

networks:
'myprojectname'-dev-network:
driver: bridge

```
</CodeBlock>

<br />
b. gitea work flow 파일을 생성한다.
<CodeBlock>
```

// .gitea/workflows/dev-build-deploy.yml

name: Dev Build & Deploy (Development Server)
on:
push:
branches: [dev]
pull_request:
branches: [dev]
types: [closed]

concurrency:
group: dev-deploy
cancel-in-progress: true

env:
DEV_URL: '배포할 사이트 URL'

jobs:
deploy:
name: Deploy to Development Server
runs-on: act-runner-1 // 👈👈 gitea actions에 기본적으로 추가되는 runner / 뒤에서 다룸

    # Node.js 환경 제공
    container:
      image: node:20-bookworm

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Docker
        run: |
          echo "Setting up Docker..."
          # Docker CLI 설치
          apt-get update --allow-insecure-repositories || true
          apt-get install -y debian-archive-keyring
          apt-get update
          apt-get install -y apt-transport-https ca-certificates curl gnupg lsb-release
          curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
          apt-get update
          apt-get install -y docker-ce-cli docker-compose-plugin

          # Docker 데몬 연결 확인
          docker --version
          docker compose version

      - name: Build and Deploy
        run: |
          echo "--- Starting Development Server Deployment ---"

          # 1. 현재 디렉토리 확인
          echo "Current directory: $(pwd)"
          echo "Directory contents:"
          ls -la

          # 2. Node.js 버전 확인
          echo "Node version: $(node --version)"
          echo "NPM version: $(npm --version)"

          # 3. 의존성 설치
          echo "Installing dependencies..."
          npm install --legacy-peer-deps

          # 4. 프로젝트 빌드
          echo "Building project..."
          npm run build

          # 5. 기존 컨테이너 정리
          echo "Cleaning up existing containers..."
          docker compose -f docker-compose.local.yml down --remove-orphans || true
          docker rm -f 'myprojectname'-dev || true

          # 6. Docker Compose로 빌드 및 배포
          echo "Building and deploying with Docker Compose..."
          docker compose -f docker-compose.local.yml build --no-cache
          docker compose -f docker-compose.local.yml up -d

          # 7. 컨테이너 상태 확인
          echo "Container status:"
          docker compose -f docker-compose.local.yml ps

          # 8. 배포 완료 확인
          echo "Deployment completed successfully!"
          echo "Application should be available at: $DEV_URL"

          echo "--- Development Server Deployment Finished ---"

```
</CodeBlock>

<br />
c. 도커 컨테이너를 실행한다.

<CodeBlock>docker compose -f docker-compose.local.yml up --build -d</CodeBlock>

<br />
d. 설정한 포트대로 페이지가 잘 뜨는지 확인 후 빌드한다.
<CodeBlock>
```

http://localhost:3002/
👇
npm run build
cd out
python -m http.server 8080 // 파이썬으로 서버 열어서
http://localhost:8080/ // 정적 파일 확인

```
</CodeBlock>
<br />
잘 뜬다면? gitea actions 가서 설정해주자.
<br />


## Gitea Actions 설정

a. 설정 > 저장소 > enable repository actions 활성화

<MDXImage
  src="/posts/cicd/giteasettings.png"
  alt="how to active gitea actions"
  style={{ width: "60%" }}
/>
(활성화 시 탭에 actions 추가 및 runners management 기본 생성됨)
<MDXImage
  src="/posts/cicd/giteaaccess.png"
  alt="runner generated upon enabling Gitea Actions"
  style={{ width: "100%" }}
/>
<br />
## nginx와 연결하는 docker 파일 생성

<CodeBlock>
```

// Dockerfile.dev

// 개발용 Dockerfile
FROM nginx:alpine

// 정적 파일을 nginx의 기본 디렉토리로 복사
COPY out/ /usr/share/nginx/html/

// 포트 80 노출
EXPOSE 80

// nginx 시작
CMD ["nginx", "-g", "daemon off;"]

```
</CodeBlock>

<CodeBlock>
```

// docker-compose.dev.yml

version: "3.8"

services:
'myprojectname'-dev:
build:
context: .
dockerfile: Dockerfile.dev
container_name: 'myprojectname'-dev
ports: - "3001:80" // 👈👈 브라우저에서 3001로 접속하면 내부 nginx 80 포트로 트래픽 전달
environment: - NODE_ENV=development
restart: unless-stopped
networks: - 'myprojectname'-dev-network # 볼륨 마운트로 소스 코드 변경사항 실시간 반영
volumes: - .:/app - /app/node_modules
extra_hosts: - "host.docker.internal:host-gateway"

networks:
'myprojectname'-dev-network:
driver: bridge

```
</CodeBlock>

<CodeBlock>
```

// .gitea/workflows/dev-build-deploy.yml

name: Dev Build & Deploy (Development Server)
on:
push:
branches: [dev]
pull_request:
branches: [dev]
types: [closed]

concurrency:
group: dev-deploy
cancel-in-progress: true

env:
DEV_URL: '배포할 사이트 URL'

jobs:
deploy:
name: Deploy to Development Server
runs-on: act-runner-1

    # Node.js 환경 제공
    container:
      image: node:20-bookworm

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Docker
        run: |
          echo "Setting up Docker..."
          # Docker CLI 설치
          apt-get update --allow-insecure-repositories || true
          apt-get install -y debian-archive-keyring
          apt-get update
          apt-get install -y apt-transport-https ca-certificates curl gnupg lsb-release
          curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
          apt-get update
          apt-get install -y docker-ce-cli docker-compose-plugin

          # Docker 데몬 연결 확인
          docker --version
          docker compose version

      - name: Build and Deploy
        run: |
          echo "--- Starting Development Server Deployment ---"

          # 1. 현재 디렉토리 확인
          echo "Current directory: $(pwd)"
          echo "Directory contents:"
          ls -la

          # 2. Node.js 버전 확인
          echo "Node version: $(node --version)"
          echo "NPM version: $(npm --version)"

          # 3. 의존성 설치
          echo "Installing dependencies..."
          npm install --legacy-peer-deps

          # 4. 프로젝트 빌드
          echo "Building project..."
          npm run build

          # 5. 기존 컨테이너 정리
          echo "Cleaning up existing containers..."
          docker compose -f docker-compose.dev.yml down --remove-orphans || true
          // 👈👈 local과 과정은 똑같고 yml 파일명만 고쳐주면 된다.
          docker rm -f 'myprojectname'-dev || true

          # 6. Docker Compose로 빌드 및 배포
          echo "Building and deploying with Docker Compose..."
          docker compose -f docker-compose.dev.yml build --no-cache // 👈👈
          docker compose -f docker-compose.dev.yml up -d // 👈👈

          # 7. 컨테이너 상태 확인
          echo "Container status:"
          docker compose -f docker-compose.dev.yml ps // 👈👈

          # 8. 배포 완료 확인
          echo "Deployment completed successfully!"
          echo "Application should be available at: $DEV_URL"

          echo "--- Development Server Deployment Finished ---"

```
</CodeBlock>

<br />
## 설정한 브랜치로 PUSH 혹은 PR

성공 시 . . . 😭😭😭😭😭!!!

<MDXImage
  src="/posts/cicd/success.png"
  alt="what gitea actions do"
  style={{ width: "50%" }}
/>

이 장엄한 초록불의 향연을 보기 전까지 빨간불을 수도 없이 만났다 . . . 😭😭😭😭😭

<br />
## nginx conf 파일 수정

<CodeBlock>
```

// 서버 내/~.conf

server {
listen 80;
server_name '배포할 사이트 URL'

    # Let's Encrypt verification path
    location ^~ /.well-known/acme-challenge/ {
        root /usr/local/nginx/html;
        try_files $uri $uri/ =404;
    }

    # Main location block - 모든 요청을 Next.js로 프록시
    location / {
        proxy_pass http://127.0.0.1:3001; // 👈👈
        proxy_http_version 1.1;

        # WebSocket
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';

        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_cache_bypass $http_upgrade;

        # Security headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    }

}

```
</CodeBlock>

nginx 테스트 및 재시작
<CodeBlock>
```

sudo nginx -t
sudo systemctl restart nginx

```
</CodeBlock>

<br />
🥳
성공
🥳🥳
<br />
이 과정을 이틀동안 겪었다. 팀장님이 성공한 김에 발표도 해보라고 하셔서 소소하게 팀 앞에서 삽질 과정 공유도 했다!
정말 정말 재미있었다. 꼭 해보고 싶었던 작업을 해서 좋았던 것도 있지만 평소에 만져볼 일이 별로 없는 서버를 마구 건드려본 점도 아주 재미있었다. 마지막에 팀원과 과정을 공유한 시간도 참 뿌듯하고 기뻤다.
<br />
성공까지 많은 에러를 만났는데 해결 과정도 차차 다뤄 볼 것이다.<br />
모바일 앱의 CI/CD 연동도 쓸 예정이다.
<br />
<br />
읽어 주신 분이 계시다면 감사합니다. 도움이 되었기를 진심으로 바랍니다. ☺️☺️

```
